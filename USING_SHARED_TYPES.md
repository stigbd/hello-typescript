# Using Shared Types in the Monorepo

This guide explains how to use the shared types from `packages/shared` across your monorepo apps.

## Overview

The `@hello-typescript/shared` package contains TypeScript types and interfaces that are used across multiple apps in the monorepo. This ensures type consistency and prevents duplication.

## Package Structure

```
packages/shared/
├── src/
│   ├── index.ts      # Main entry point (exports everything)
│   └── types.ts      # Type definitions
├── dist/             # Compiled output (generated by TypeScript)
├── package.json
└── tsconfig.json
```

## Current Shared Types

### Animal Types

```typescript
// Base interface
interface Animal {
  name: string;
  age: number;
  type: "cat" | "dog";
}

// Cat-specific interface
interface Cat extends Animal {
  type: "cat";
  livesLeft: number;
}

// Dog-specific interface
interface Dog extends Animal {
  type: "dog";
  breed: string;
}

// Discriminated union type
type AnimalType = Cat | Dog;
```

## How to Use Shared Types

### Step 1: Add the Dependency

The shared package is already configured as a workspace dependency in both `apps/api` and `apps/web`. If you add a new app, add it as a dependency:

```bash
# From the root of the monorepo
pnpm add @hello-typescript/shared --filter @hello-typescript/your-new-app --workspace
```

### Step 2: Import the Types

In your app code, import the types you need:

```typescript
// Import specific types
import type { Animal, Cat, Dog, AnimalType } from "@hello-typescript/shared";

// Or import everything
import type * as SharedTypes from "@hello-typescript/shared";
```

### Step 3: Use the Types

#### Example: In the Web App (React)

```typescript
// apps/web/src/App.tsx
import type { AnimalType } from "@hello-typescript/shared";
import { useState } from "react";

function App() {
  const [animals, setAnimals] = useState<AnimalType[]>([]);

  // TypeScript now knows that each animal has the correct shape
  animals.forEach((animal) => {
    console.log(animal.name); // ✓ Valid
    if (animal.type === "cat") {
      console.log(animal.livesLeft); // ✓ Valid (type narrowed to Cat)
    } else {
      console.log(animal.breed); // ✓ Valid (type narrowed to Dog)
    }
  });
}
```

#### Example: In the API (Express)

```typescript
// apps/api/src/routes/animals.ts
import type { AnimalType, Cat, Dog } from "@hello-typescript/shared";
import { Request, Response } from "express";

function getAnimals(req: Request, res: Response) {
  const animals: AnimalType[] = [
    { type: "cat", name: "Whiskers", age: 3, livesLeft: 9 },
    { type: "dog", name: "Buddy", age: 5, breed: "Labrador" },
  ];
  
  res.json(animals);
}
```

## Build Process

The shared package must be built before it can be used by other apps:

```bash
# Build only the shared package
pnpm --filter @hello-typescript/shared build

# Build everything (builds shared first, then apps)
pnpm build
```

The build process:
1. Compiles TypeScript to JavaScript in `dist/`
2. Generates `.d.ts` type declaration files
3. Creates source maps for debugging

## Type Safety Benefits

### 1. Single Source of Truth

Types are defined once in `packages/shared` and used everywhere. If you update a type, all apps get the update.

### 2. Compile-Time Checking

TypeScript ensures type consistency across apps:

```typescript
// This will cause a compile error if the API and web app 
// have different expectations for the Animal type
const cat: Cat = fetchCatFromAPI(); // ✓ Type-safe
```

### 3. Refactoring Safety

When you change a type in `packages/shared`, TypeScript will immediately show you all the places in your apps that need to be updated.

## Adding New Shared Types

### 1. Add the Type Definition

Edit `packages/shared/src/types.ts`:

```typescript
export interface User {
  id: string;
  email: string;
  name: string;
}
```

### 2. Rebuild the Package

```bash
pnpm --filter @hello-typescript/shared build
```

### 3. Import and Use

```typescript
import type { User } from "@hello-typescript/shared";

const user: User = {
  id: "123",
  email: "user@example.com",
  name: "John Doe",
};
```

## Development Workflow

### Watch Mode for Shared Package

When actively developing shared types, run the package in watch mode:

```bash
pnpm --filter @hello-typescript/shared dev
```

This automatically rebuilds when you make changes to the types.

### Full Development Workflow

```bash
# Terminal 1: Watch shared types
pnpm --filter @hello-typescript/shared dev

# Terminal 2: Run the API in dev mode
pnpm --filter @hello-typescript/api dev

# Terminal 3: Run the web app in dev mode
pnpm --filter @hello-typescript/web dev
```

## Integration with Runtime Validation

In the API, we use Zod for runtime validation while maintaining compatibility with shared types:

```typescript
// apps/api/src/models/animal.ts
import type { Cat as SharedCat } from "@hello-typescript/shared";
import { z } from "zod";

// Zod schema for runtime validation
export const CatSchema = z.object({
  type: z.literal("cat"),
  name: z.string().min(1),
  age: z.number().int().positive(),
  livesLeft: z.number().int().min(0).max(9),
});

// Inferred type from Zod (compatible with SharedCat)
export type Cat = z.infer<typeof CatSchema>;

// Re-export shared type for convenience
export type { SharedCat };
```

This approach gives you:
- **Runtime validation** with Zod in the API
- **Compile-time type checking** with shared types
- **Type consistency** across the monorepo

## Troubleshooting

### Problem: "Cannot find module '@hello-typescript/shared'"

**Solution:** Make sure you've built the shared package:

```bash
pnpm --filter @hello-typescript/shared build
```

### Problem: Types are outdated after making changes

**Solution:** Rebuild the shared package:

```bash
pnpm --filter @hello-typescript/shared build

# Or rebuild everything
pnpm build
```

### Problem: Import paths not resolving

**Solution:** Check that:
1. The shared package is listed in your app's `package.json` dependencies
2. You're using the correct package name: `@hello-typescript/shared`
3. The shared package has been built (`dist/` folder exists)

### Problem: Type errors after updating shared types

**Solution:** This is expected! TypeScript is showing you where updates are needed. Fix the errors in each app to match the new type structure.

## Best Practices

### 1. Keep Shared Types Pure

Shared types should only contain type definitions, interfaces, and type utilities. Don't include:
- Business logic
- API calls
- UI components
- Framework-specific code

### 2. Use Discriminated Unions

For types with variants, use discriminated unions:

```typescript
// ✓ Good: Discriminated union with literal type
type Animal = 
  | { type: "cat"; livesLeft: number }
  | { type: "dog"; breed: string };

// ✗ Avoid: Makes type narrowing difficult
type Animal = {
  type: string;
  livesLeft?: number;
  breed?: string;
};
```

### 3. Version Shared Types Carefully

Changes to shared types affect all apps. Consider:
- Adding optional fields instead of required ones
- Creating new types instead of modifying existing ones
- Coordinating changes across apps

### 4. Document Complex Types

Add JSDoc comments for complex types:

```typescript
/**
 * Represents an animal in the system.
 * Uses a discriminated union to support different animal types.
 * 
 * @example
 * const cat: Animal = {
 *   type: "cat",
 *   name: "Whiskers",
 *   age: 3,
 *   livesLeft: 9
 * };
 */
export interface Animal {
  // ...
}
```

## Next Steps

- Add more shared types as your monorepo grows
- Consider adding shared utilities and constants
- Explore adding shared validation schemas
- Set up automated tests for type compatibility

## Related Documentation

- [Monorepo Setup Guide](./MONOREPO_SETUP.md)
- [Apps vs Packages](./APPS_VS_PACKAGES.md)
- [Architecture Overview](./ARCHITECTURE.md)
